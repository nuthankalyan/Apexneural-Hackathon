import jsPDF from 'jspdf';

export interface PdfOptions {
  title: string;
  subtitle?: string;
  author?: string;
  subject?: string;
  keywords?: string;
  pageSize?: 'a4' | 'letter';
  orientation?: 'portrait' | 'landscape';
}

export interface RfpDocument {
  title: string;
  description: string;
  content: string;
  createdAt: string;
  createdBy?: string;
}

/**
 * Generates a professionally formatted PDF from an RFP document
 */
export function generateRfpPdf(document: RfpDocument, options: PdfOptions = { title: 'Request for Proposal' }) {
  // Initialize PDF with options
  const pdf = new jsPDF({
    orientation: options.orientation || 'portrait',
    unit: 'mm',
    format: options.pageSize || 'a4',
  });

  // Set document properties
  pdf.setProperties({
    title: options.title,
    subject: options.subject || 'Request for Proposal Document',
    author: options.author || 'ProcureAgents',
    keywords: options.keywords || 'RFP, proposal, procurement',
    creator: 'ProcureAgents RFP Generator'
  });

  // Get page dimensions
  const pageWidth = pdf.internal.pageSize.width;
  const pageHeight = pdf.internal.pageSize.height;
  const margin = 20;
  const contentWidth = pageWidth - (margin * 2);
  
  // Add header content
  addHeader(pdf, document, options, pageWidth, margin);
  
  // Add body content
  let yPosition = 75; // Starting position after header
  yPosition = addBody(pdf, document, contentWidth, margin, yPosition);
  
  // Add pagination to all pages
  addPagination(pdf);
  
  return pdf;
}

/**
 * Add header content to the PDF
 */
function addHeader(pdf: jsPDF, document: RfpDocument, options: PdfOptions, pageWidth: number, margin: number) {
  // Title
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(22);
  pdf.setTextColor(0, 51, 102);
  pdf.text(options.title.toUpperCase(), pageWidth / 2, 30, { align: 'center' });
  
  // Subtitle
  pdf.setFontSize(16);
  pdf.text(document.title, pageWidth / 2, 40, { align: 'center' });
  
  // Date line
  pdf.setFont('helvetica', 'italic');
  pdf.setFontSize(10);
  pdf.setTextColor(100, 100, 100);
  
  const dateStr = new Date(document.createdAt).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
  
  const createdByText = document.createdBy ? `Generated by: ${document.createdBy} | ` : '';
  pdf.text(`${createdByText}Date: ${dateStr}`, pageWidth / 2, 50, { align: 'center' });
  
  // Horizontal line
  pdf.setDrawColor(0, 51, 102);
  pdf.setLineWidth(0.5);
  pdf.line(margin, 60, pageWidth - margin, 60);
}

/**
 * Parse and add body content to PDF
 */
function addBody(pdf: jsPDF, document: RfpDocument, contentWidth: number, margin: number, startY: number): number {
  let y = startY;
  
  // Add description
  pdf.setFont('helvetica', 'normal');
  pdf.setFontSize(11);
  pdf.setTextColor(50, 50, 50);
  
  const descLines = pdf.splitTextToSize(document.description, contentWidth);
  pdf.text(descLines, margin, y);
  y += descLines.length * 7;
  
  // Add spacing
  y += 10;

  // Process the main content - using the already defined function
  const sections = splitIntoSections(document.content);
  
  for (const section of sections) {
    // Check if we need a new page
    if (y > pdf.internal.pageSize.height - 30) {
      pdf.addPage();
      y = 30;
    }

    // Section headers (like "### 3. SCOPE OF WORK")
    if (section.isHeader) {
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(14);
      pdf.setTextColor(0, 51, 153); // Blue color for headings
      
      // Clean up any markdown symbols
      const cleanTitle = section.title.replace(/^#+\s*/, '').toUpperCase();
      pdf.text(cleanTitle, margin, y);
      y += 10;
      
      // Add underline for section headers
      pdf.setDrawColor(0, 51, 153);
      pdf.setLineWidth(0.2);
      pdf.line(margin, y - 4, margin + 100, y - 4);
      y += 6;
    } 
    else {
      // Process the section content with smart formatting
      y = processFormattedContent(pdf, section.content, contentWidth, margin, y);
    }
  }
  
  return y;
}

/**
 * Split document content into sections (with headers)
 */
function splitIntoSections(content: string) {
  // Normalize line endings
  const normalizedContent = content.replace(/\r\n/g, '\n');
  
  // Split by section headers (numbered sections)
  const sections = [];
  
  // First split the content into lines
  const lines = normalizedContent.split('\n');
  
  let currentSection = {
    isHeader: false,
    title: '',
    content: ''
  };
  
  let inSection = false;
  
  // Process line by line
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Check if this line is a section header (e.g., "1. SCOPE OF WORK" or "### 2. REQUIREMENTS")
    const headerMatch = line.match(/^(?:#+\s*)?(\d+\.\s+[A-Z][A-Z\s]+)/);
    
    if (headerMatch) {
      // If we were already in a section, add it to our sections array
      if (inSection) {
        sections.push(currentSection);
      }
      
      // Start a new section
      currentSection = {
        isHeader: true,
        title: headerMatch[1],
        content: ''
      };
      
      // Add the rest of the line after the header
      const contentStart = headerMatch[0].length;
      const restOfLine = line.substring(contentStart).trim();
      
      if (restOfLine) {
        currentSection.content += restOfLine + '\n';
      }
      
      inSection = true;
    } 
    // Not a header, so add to current section's content
    else if (inSection) {
      currentSection.content += line + '\n';
    }
    // If we haven't encountered a header yet, start a default section
    else {
      if (!currentSection.content && line.trim()) {
        currentSection = {
          isHeader: false,
          title: '',
          content: line + '\n'
        };
        inSection = true;
      } else if (line.trim()) {
        currentSection.content += line + '\n';
      }
    }
  }
  
  // Add the last section if it has content
  if (inSection && currentSection.content.trim()) {
    sections.push(currentSection);
  }
  
  // If no sections were created but we have content, add a default section
  if (sections.length === 0 && normalizedContent.trim()) {
    sections.push({
      isHeader: false,
      title: '',
      content: normalizedContent
    });
  }
  
  return sections;
}

/**
 * Process content with smart formatting based on content structure
 */
function processFormattedContent(pdf: jsPDF, content: string, contentWidth: number, margin: number, startY: number): number {
  let y = startY;
  
  // Split content into logical blocks (paragraphs, lists, etc.)
  const blocks = splitIntoBlocks(content);
  
  for (const block of blocks) {
    // Check if we need a new page
    if (y > pdf.internal.pageSize.height - 30) {
      pdf.addPage();
      y = 30;
    }
    
    // Process based on block type
    if (block.type === 'heading') {
      // Subsection heading
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.setTextColor(0, 51, 153); // Blue for headings
      
      const headingLines = pdf.splitTextToSize(block.content, contentWidth);
      pdf.text(headingLines, margin, y);
      y += headingLines.length * 6 + 4;
    } 
    else if (block.type === 'subheading') {
      // Minor heading or emphasized text
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(11);
      pdf.setTextColor(50, 50, 50);
      
      const subheadingLines = pdf.splitTextToSize(block.content, contentWidth);
      pdf.text(subheadingLines, margin, y);
      y += subheadingLines.length * 5 + 3;
    }
    else if (block.type === 'list') {
      // Bullet point list
      const listItems = block.content.split('\n').filter(item => item.trim());
      
      for (const item of listItems) {
        // Check if we need a new page
        if (y > pdf.internal.pageSize.height - 30) {
          pdf.addPage();
          y = 30;
        }
        
        // Clean the item text (remove bullet characters)
        const itemText = item.replace(/^[\s*\-•]+\s*/, '').trim();
        
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        pdf.setTextColor(0, 0, 0);
        
        // Add bullet point
        pdf.text('•', margin, y);
        
        // Add indented text
        const itemLines = pdf.splitTextToSize(itemText, contentWidth - 8);
        pdf.text(itemLines, margin + 6, y);
        y += itemLines.length * 5 + 2;
      }
    } 
    else if (block.type === 'paragraph') {
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      pdf.setTextColor(0, 0, 0);
      
      const paraLines = pdf.splitTextToSize(block.content, contentWidth);
      pdf.text(paraLines, margin, y);
      y += paraLines.length * 5 + 4;
    }
  }
  
  return y;
}

/**
 * Split content into logical blocks for better formatting
 */
function splitIntoBlocks(content: string) {
  const blocks = [];
  const lines = content.split('\n');
  let currentBlock = null;
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      // Empty line - close current block if exists
      if (currentBlock) {
        blocks.push(currentBlock);
        currentBlock = null;
      }
      continue;
    }
    
    // Analyze the line to determine its type
    const isListItem = trimmedLine.match(/^[\s*\-•]+\s+/) !== null;
    const isHeading = trimmedLine.match(/^(\d+\.\d+|\*\*\*)\s+[A-Z]/) !== null;
    const isSubheading = trimmedLine.match(/^\s*([\w\s]+):\s*$/) !== null || 
                        trimmedLine.match(/^\s*\*\*(.+)\*\*\s*$/) !== null;
    
    // Determine block type based on line analysis
    let blockType;
    if (isHeading) blockType = 'heading';
    else if (isSubheading) blockType = 'subheading';
    else if (isListItem) blockType = 'list';
    else blockType = 'paragraph';
    
    // Start a new block or continue current block
    if (!currentBlock || currentBlock.type !== blockType) {
      // Close current block if exists
      if (currentBlock) {
        blocks.push(currentBlock);
      }
      
      // Start new block
      currentBlock = {
        type: blockType,
        content: trimmedLine
      };
    } else {
      // Continue current block
      currentBlock.content += '\n' + trimmedLine;
    }
  }
  
  // Add the last block if it exists
  if (currentBlock) {
    blocks.push(currentBlock);
  }
  
  return blocks;
}

// Define interface for content blocks
interface ContentBlock {
  type: 'heading' | 'subheading' | 'list' | 'paragraph';
  content: string;
}

// Process real paragraphs with multiple sentences as paragraphs, not as lists
function improveBlockTypes(blocks: ContentBlock[]): ContentBlock[] {
  return blocks.map(block => {
    // If it's already identified as a paragraph, keep it that way
    if (block.type === 'paragraph') return block;
    
    // If it's identified as a list but has multiple sentences and no * or - markers,
    // it might actually be a paragraph
    if (block.type === 'list') {
      const hasBulletMarkers = block.content.match(/^[\s*\-•]+\s+/m);
      const hasSentences = block.content.split('.').length > 2;
      
      if (!hasBulletMarkers && hasSentences) {
        return {
          type: 'paragraph',
          content: block.content
        };
      }
    }
    
    return block;
  });
}

/**
 * Add page numbers to all pages
 */
function addPagination(pdf: jsPDF) {
  const totalPages = pdf.internal.pages.length - 1; // Correct way to get page count
  const pageWidth = pdf.internal.pageSize.width;
  
  for (let i = 1; i <= totalPages; i++) {
    pdf.setPage(i);
    pdf.setFont('helvetica', 'italic');
    pdf.setFontSize(8);
    pdf.setTextColor(100, 100, 100);
    
    // Add page number at the bottom
    pdf.text(
      `Page ${i} of ${totalPages} | Generated by ProcureAgents`,
      pageWidth / 2,
      pdf.internal.pageSize.height - 10,
      { align: 'center' }
    );
  }
}
